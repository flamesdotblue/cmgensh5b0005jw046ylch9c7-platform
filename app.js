// VibeFeed — Pure JS aggregator
const state = { sources: new Set(["hn","reddit","github"]), rssUrl: "", items: [], loading: false, query: "", page: 0 };
const feedEl = document.getElementById('feed'); const statusEl = document.getElementById('status'); const searchInput = document.getElementById('searchInput'); const refreshBtn = document.getElementById('refreshBtn'); const rssUrlInput = document.getElementById('rssUrl');
const timeAgo = ts=>{const s=Math.floor((Date.now()-ts)/1000); if(s<60)return `${s}s ago`; const m=Math.floor(s/60); if(m<60)return `${m}m ago`; const h=Math.floor(m/60); if(h<24)return `${h}h ago`; const d=Math.floor(h/24); return `${d}d ago`};
const setStatus = m=> statusEl.textContent = m || '';
const normalizeItem = ({ id, source, author, title, url, ts, meta={} })=>({ id, source, author, title, url, ts, meta });
async function fetchHN(){ const r = await fetch(`https://hn.algolia.com/api/v1/search_by_date?tags=story&hitsPerPage=30&page=${state.page}`); if(!r.ok) throw new Error('HN failed'); const d = await r.json(); return d.hits.map(h=>normalizeItem({ id:`hn_${h.objectID}`, source:'hn', author:h.author, title:h.title||h.story_title||'HN Story', url:h.url||h.story_url||`https://news.ycombinator.com/item?id=${h.objectID}`, ts:new Date(h.created_at).getTime(), meta:{ points:h.points??0, comments:h.num_comments??0 }})); }
async function fetchReddit(){ const r = await fetch(`https://www.reddit.com/r/all/new.json?limit=30`); if(!r.ok) throw new Error('Reddit failed'); const d = await r.json(); return d.data.children.map(({data:x})=>normalizeItem({ id:`reddit_${x.id}`, source:'reddit', author:x.author, title:x.title, url:x.url_overridden_by_dest||`https://reddit.com${x.permalink}`, ts:x.created_utc*1000, meta:{ subreddit:x.subreddit, score:x.score, comments:x.num_comments }})); }
async function fetchGitHub(){ const r = await fetch(`https://api.github.com/events`, { headers:{'Accept':'application/vnd.github+json'} }); if(!r.ok) throw new Error('GitHub failed'); const d = await r.json(); return d.map(ev=>normalizeItem({ id:`gh_${ev.id}`, source:'github', author:ev.actor?.login||'unknown', title:`${ev.type} — ${ev.repo?.name||''}`, url:`https://github.com/${ev.repo?.name||''}`, ts:new Date(ev.created_at).getTime(), meta:{ type:ev.type } })); }
async function fetchRSS(url){ if(!url) return []; const r = await fetch(`https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`); if(!r.ok) throw new Error('RSS failed'); const d = await r.json(); if(!d.items) return []; return d.items.slice(0,30).map(item=>normalizeItem({ id:`rss_${(item.guid||item.link||item.title).slice(0,64)}`, source:'rss', author:item.author||d.feed?.title||'', title:item.title, url:item.link, ts:new Date(item.pubDate||Date.now()).getTime(), meta:{ feed:d.feed?.title||'RSS' } })); }
function extraMeta(it){ if(it.source==='hn') return `${it.meta.points??0} points • ${it.meta.comments??0} comments`; if(it.source==='reddit') return `r/${it.meta.subreddit} • ${it.meta.score??0} points • ${it.meta.comments??0} comments`; if(it.source==='github') return it.meta.type||''; if(it.source==='rss') return it.meta.feed||'RSS'; return '' }
function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#039;") }
function render(items){ const feedEl = document.getElementById('feed'); feedEl.innerHTML=''; const q=state.query.trim().toLowerCase(); const filtered = items.filter(it=>!q || it.title?.toLowerCase().includes(q) || it.author?.toLowerCase().includes(q)); for(const it of filtered){ const card=document.createElement('article'); card.className='card'; const badgeClass={hn:'hn',reddit:'reddit',github:'github',rss:'rss'}[it.source]||''; card.innerHTML = `<div class=\"actions\"><span class=\"badge ${badgeClass}\">${it.source.toUpperCase()}</span><span class=\"meta\">by ${it.author||'unknown'} • ${timeAgo(it.ts)}</span></div><div class=\"title\"><a href=\"${it.url}\" target=\"_blank\" rel=\"noopener noreferrer\">${escapeHtml(it.title||'Untitled')}</a></div><div class=\"meta\">${extraMeta(it)}</div>`; feedEl.appendChild(card);} setStatus(filtered.length?'' : 'No items match your filters yet.') }
async function load(){ if(state.loading) return; state.loading = true; setStatus('Loading vibes…'); try{ const tasks=[]; if(state.sources.has('hn')) tasks.push(fetchHN()); if(state.sources.has('reddit')) tasks.push(fetchReddit()); if(state.sources.has('github')) tasks.push(fetchGitHub()); if(state.sources.has('rss') && state.rssUrl) tasks.push(fetchRSS(state.rssUrl)); const results = await Promise.allSettled(tasks); const merged = results.flatMap(r=> r.status==='fulfilled'? r.value:[]); merged.sort((a,b)=> b.ts-a.ts); state.items = merged; render(state.items); setStatus(''); } catch(e){ console.error(e); setStatus('Some sources failed to load. Try refreshing.'); } finally { state.loading=false; } }
function attachEvents(){ searchInput.addEventListener('input', e=>{ state.query = e.target.value; render(state.items); }); refreshBtn.addEventListener('click', ()=>{ state.page = 0; load(); }); document.querySelectorAll('.source-toggles input[type="checkbox"]').forEach(t=>{ t.addEventListener('change', e=>{ const src = e.target.value; if(e.target.checked) state.sources.add(src); else state.sources.delete(src); if(src==='rss' && e.target.checked && rssUrlInput.value) state.rssUrl = rssUrlInput.value; load(); }); }); rssUrlInput.addEventListener('change', e=>{ state.rssUrl = e.target.value.trim(); if(state.sources.has('rss') && state.rssUrl) load(); }); window.addEventListener('scroll', ()=>{ const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 200; if(nearBottom && !state.loading){ state.page += 1; load(); } }); }
attachEvents(); load();
